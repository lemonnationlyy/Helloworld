##分库分表（数据库sharding） 读写分离 nosql缓存
##使用消息队列 异步加载 过载保护 负载均衡

#负载均衡
##轮询调度算法(Round-Robin Scheduling)
　　轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。
　　算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。
　　轮询调度算法流程
　　假设有一组服务器N台，S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。其算法如下：
j = i;
do{
    j = (j + 1) mod n;
    i = j;
    return Si;
} while (j != i);
return NULL;

轮询调度算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询调度算法容易导致服务
器间的负载不平衡。
所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。

##权重轮询调度算法(Weighted Round-Robin Scheduling)
　　上面所讲的轮询调度算法并没有考虑每台服务器的处理能力，在实际情况中，可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处
理能力会不一样。所以，我们根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。
　　权重轮询调度算法流程
　　假设有一组服务器S = {S0, S1, …, Sn-1}，W(Si)表示服务器Si的权值，一个指示变量i表示上一次选择的服务器，指示变量cw表示当前调度的权值，
max(S)表示集合S中所有服务器的最大权值，gcd(S)表示集合S中所有服务器权值的最大公约数。变量i初始化为-1，cw初始化为零。其算法如下：
while (true) {
  i = (i + 1) mod n;
  if (i == 0) {
     cw = cw - gcd(S);
     if (cw <= 0) {
       cw = max(S);
       if (cw == 0)
         return NULL;
     }
  }
  if (W(Si) >= cw)
    return Si;
}

由于权重轮询调度算法考虑到了不同服务器的处理能力，所以这种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。所以，在
实际应用中比较常见。

```权重轮询调度的算法本质上是先以最高的权重遍历所有server，然后将权重扣除最大公约数再以这个权重遍历所有server直到权重扣光，分配结束```