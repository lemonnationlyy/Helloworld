#面向对象的特点
  ##抽象
  抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。只关注属性行为，不关注细节。
  ##继承
  继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类，得到继承信息的类被称为子类。继承让变化中的软件系统有了一定的延续性，
  同时继承也是封装程序中可变因素的重要手段。
  ##封装
  封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
  如getter/setter
  ##多态
  多态性是指允许不同子类型的对象对同一消息作出不同的响应。
  编译时多态  方法重载。
  运行时多态：方法重写。当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。
            继承+重写+父类引用指向子类对象=同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为
            
#java权限控制
    修饰符	  当前类	  同 包	  子 类	  其他包
    public	 	√       √	    √	    √
    protected	√	    √	    √	    ×
    default	    √	    √	    ×	    ×
    private	    √	    ×	    ×	    ×
    
#基本类型和包装类
  给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf。
  ```
      //整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象
      public static Integer valueOf(int i) {
          if (i >= IntegerCache.low && i <= IntegerCache.high)
              return IntegerCache.cache[i + (-IntegerCache.low)];
          return new Integer(i);
      }
  ```

#解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法
  通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放
  在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为
  Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息
  、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区
  的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发
  StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。
  
  String str = new String("hello");
  上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。
  
  补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和"逃逸分析"技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象
  一定分配在堆上这件事情已经变得不那么绝对了。
  
  补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，
  String类的intern()方法就是这样的。
  看看下面代码的执行结果是什么并且比较一下Java 7以前和以后的运行结果是否一致。
  
  String s1 = new StringBuilder("go")
      .append("od").toString();
  System.out.println(s1.intern() == s1);
  String s2 = new StringBuilder("ja")
      .append("va").toString();
  System.out.println(s2.intern() == s2);
  
  String s1 = "Programming";
  String s2 = new String("Programming");
  String s3 = "Program";
  String s4 = "ming";
  String s5 = "Program" + "ming";
  String s6 = s3 + s4;
  System.out.println(s1 == s2);
  System.out.println(s1 == s5);
  System.out.println(s1 == s6);
  System.out.println(s1 == s6.intern());
  System.out.println(s2 == s2.intern());
  
  ***栈上分配
  JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提
  高系统性能。 
  栈上分配的一个技术基础是进行逃逸分析，逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。另一个是标量替换，允许将对象打散分配在栈上，
  比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。
  ***对象分配流程
  首先如果开启栈上分配，JVM会先进行栈上分配，如果没有开启栈上分配或则不符合条件的则会进行TLAB分配，如果TLAB分配不成功，再尝试在eden区分配，
  如果对象满足了直接进入老年代的条件，那就直接分配在老年代。
  
#hashCode方法和equals方法 以及== 看java特种兵
  hashCode的目的是为了散列，类似于索引，用于高速查找 用于hash集合类中 
  equals是为了比较两个对象
  如果两个对象equals 那么hashCode必须相等；如果hashCode相等 不一定equals
  
#集合面试 
  ![avatar](C:\Users\59685\IdeaProjects\Helloworld\img\java集合.png)
  1、ArrayList和Vector的区别（是否有序、是否重复、数据结构、底层实现）
  
  ArrayList和Vector都实现了List接口，他们都是有序集合，并且存放的元素是允许重复的。它们的底层都是通过数组来实现的，因此列表这种数据结构检
  索数据速度快，但增删改速度慢。
  
  而ArrayList和Vector的区别主要在两个方面：
  
  第一，线程安全。Vector是线程安全的，而ArrayList是线程不安全的。因此在如果集合数据只有单线程访问，那么使用ArrayList可以提高效率。而如果
  有多线程访问你的集合数据，那么就必须要用Vector，因为要保证数据安全。
  
  第二，数据增长。ArrayList和Vector都有一个初始的容量大小，当存储进它们里面的元素超过了容量时，就需要增加它们的存储容量。ArrayList每次增
  长原来的0.5倍，而Vector增长原来的一倍。ArrayList和Vector都可以设置初始空间的大小，Vector还可以设置增长的空间大小，而ArrayList没有提
  供设置增长空间的方法。
  
  2、HashMap和Hashtable的区别
  
  HashMap和Hashtable都实现了Map接口，并且都是key-value的数据结构。它们的不同点主要在三个方面：
  
  第一，Hashtable是Java1.1的一个类，它基于陈旧的Dictionary类。而HashMap是Java1.2引进的Map接口的一个实现。
  
  第二，Hashtable是线程安全的，也就是说是线程同步的，而HashMap是线程不安全的。也就是说在单线程环境下应该用HashMap，这样效率更高。
  
  第三，HashMap允许将null值作为key或value，但Hashtable不允许（会抛出NullPointerException）。
  
  3、List 和 Map 区别？（数据结构，存储特点）
  
  这个要从两个方面来回答，一方面是List和Map的数据结构，另一方面是存储数据的特点。在数据结构方面，List存储的是单列数据的集合，而Map存储的是
  key、value类型的数据集合。在数据存储方面，List存储的数据是有序且可以重复的，而Map中存储的数据是无序且key值不能重复（value值可以重复）。
  
  4、List、Map、Set三个接口，存取元素时，各有什么特点？
  
  List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能
  有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则
  B对象存储不进去。所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含
  有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的
  元素，再逐一遍历各个元素。
  
  List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票
  有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对
  象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索
  引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，
  再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。
  
  Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复
  的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以
  获得所有的key的结合（map.keySet()），还可以获得所有的value的结合（map.values()），还可以获得key和value组合成的Map.Entry对象的集合
  （map.entrySet()）。
  
  List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。
  
  5. HashMap的底层原理！！！！！！！！！！！！！！！
  百度一下
  你就知道
  
#值传递和引用传递
  Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程
  中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。
  
#为什么函数重载不可以根据返回类型区分？
  int Fun(int a, int b);
  long Fun(int a, int b);
  如果代码里直接运行函数，并不将返回值存储起来，那么应该调用哪个？
  Fun(1, 2);
  
#描述一下JVM加载class文件的原理机制
  JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类
  文件中的类。 
  由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加
  载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与
  所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态
  变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类
  还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 
  类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器
  （java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在
  该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其
  子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
  
  Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
  Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
  System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录
  中记载类，是用户自定义加载器的默认父加载器。
  ![avatar](C:\Users\59685\IdeaProjects\Helloworld\img\双亲委派加载.png)
  
#抽象类和抽象方法的异同
  抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实
  现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且
  其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成
  员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

#java有内存泄漏么
  理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在
  无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是
  不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的
  代码也会导致内存泄露
  
#阐述静态变量和实例变量的区别。 
  静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有
  一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。
 
#简述设计模式
  - 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同
  的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 
  - 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、
  保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 
  - 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 
  - 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 
 
#双检查锁机制单例
```
  public class Singleton {  
      private static volatile Singleton instance = null;  
      private Singleton(){}  
        
      public static Singleton getInstance(){  
          if(instance == null){  
              synchronized(Singleton.class){  
                  if(instance == null){  
                      instance = new Singleton();  
                  }  
              }  
          }  
          return instance;  
      }  
  }  
```
 
#大型网站架构设计
  - 分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服
  务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网
  站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视
  图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算
  资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。 
  - 分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的
  分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署
  ，提供网站的并发处理能力和功能的扩展。 
  - 分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器
  的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产
  品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及
  MapReduce分布式计算框架来处理。 
  - 集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。 
  - 缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热
  点数据都是对缓存技术的使用。 
  - 异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼
  此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异
  步技术），同时还可以起到削峰作用（应对瞬时高并发）。&quot；能推迟处理的都要推迟处理"是网站优化的第二定律，而异步是践行网站优化第二定律的重
  要手段。 
  - 冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高
  可用性的重要保证。
  
#常见的后端优化方法
  ① 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些
  读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据
  写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系
  统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题： 
  - 频繁修改的数据； 
  - 数据不一致与脏读； 
  - 缓存雪崩（可以采用分布式缓存服务器集群加以解决，memcached是广泛采用的解决方案）； 
  - 缓存预热； 
  - 缓存穿透（恶意持续请求不存在的数据）。 
  ② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销
  活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，
  订单系统都采用了消息队列来处理。 
  ③ 使用集群。 
  ④ 代码优化： 
  - 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方
  面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致
  的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很
  好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。 
  - 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方
  式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提
  供了必要的基础。 
  - 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，
  另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。
 
#事务ACID和分布式CAP理论
  ACID 
  A atomicity 原子性
  C consistency 一致性
  I isolation 隔离性
  D durability 持久性
  
  事务隔离：read uncommitted
          read committed
          repeatable read
          serializable
          
  CAP
  Consistency 、Availability 、Partition tolerance最多只能满足两项
  放弃P：集中式
  放弃A：网络分区故障则停用服务
  放弃C：放弃强一致性 选择最终一致性
  

#排序查找算法
  Sort package
#分布式锁 zk应用
  http://blog.csdn.net/youmengdaigu/article/details/44134233
  分布式锁的实现 自己也写了一个 但是没有解决网络故障引起的死锁 在帖子里有解决方案

  
#redis 缓存原理

#读写分离 分库分表 数据库集群

#JMS规范 点对点/发布订阅 MQ kafka

#多线程 线程池 NIO 

#nginx 负载均衡