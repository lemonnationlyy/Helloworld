#Unix进程控制
##进程调度与切换
  Unix是单纯的分时系统，未设置高级调度(作业调度)，只设置了中级调度(进程对换)和低级调度(进程调度)
###1.引起进程调度的原因
  Unix系统是分时系统，因而`时钟中断处理程序`每隔一段时间就会对`要求进程调度程序`进行调度的标志run予以置位，引起调度程序重新调度
  当进程执行了wait、exit、sleep等系统调用要放弃处理机
  进程执行完系统调用功能而从核心态返回到用户态时，出现了更高优先级的进程，内核应抢占当前进程的处理机引起调度
###2.调度算法
  采用动态优先数轮转调度法:
  进行调度时首先从处于`内存就绪`或者`被抢占`状态的进程中选择一个优先数最小(优先级最高)的进程
  如果有多个最高优先级进程，内核将选择其中处于就绪状态或被抢占状态最久的进程，将其从队列中移出兵切换上下文恢复运行
  
##进程同步与通信
  sleep/wakeUp同步机制 管道(pipe)机制 信号(signal)机制 IPC进程同步软件包(包括消息机制 共享内存机制 信号量机制)
  
###信号机制(软中断)
  信号：1~19中的某个整数用来代表某一事先约定好的简单消息
  和硬中断的关系：都采用异步通信方式，在检测出有信号或者有中断时，两者都暂停正在执行的程序而转去执行相应的处理程序，处理完后再返回原来的断点；
                两者对信号或中断都可以加以屏蔽
                但是中断有优先级，信号机制没有，所有的信号都是平等的；信号处理程序是在用户态霞运行的，而中断处理程序则是在核心态下运行的
                中断相应是及时的，而对信号的响应通常来说都有较长时间的延迟
  发送信号：由发送进程吧信号送至制定目标进程的proc结构中信号域，如果目标进程正在一个可被中断的优先级上睡眠，核心便将目标进程唤醒
           (一个进程的信号域中有多个位置代表已有多种类型的信号到达，对于一类信号只能记住某一个)
           进程可利用系统调用kill向另一进程或一组进程发送一个信号
  对信号的处理：当一个进程进入或退出一个低优先级睡眠状态时，或一个进程即将从核心态返回到用户态时
              (用户程序需要做一些内核态的事如读取文件或者从键盘获取输入， 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作，这时
              需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令 ，这种机制叫系统调用, 在CPU中的实现称之为陷阱指
              令(Trap Instruction))
              核心都要检查该进程是否已经收到信号。进程处于核心态不处理信号，切换回用户态才处理信号。处理分为func=1,0，非0非1整数
              1：不做处理；0：进程自我终止（缺省值）；非0非1整数：用户转为用户态后，便转向相应信号的处理程序，处理完返回断点
              
###管道机制
  管道：能够连接一个写进程和一个读进程、并允许他们以生产者消费者方式进行通信的一个共享文件，又称pipe文件。写进程从管道入端将数据写入管道，
       读进程从出端读出数据
  无名管道、有名管道
  无名管道的读写：
       只使用索引节点的10位直接地址，作为一个循环队列来管理，设置一个读指针和写指针（pipe文件只能占用十个盘块）
       进程互斥：读写操作都需要对索引节点上锁

###消息队列

###共享存储区机制(速度最快的通信机制)

###信号量集机制(信号量的集合 所有操作都是原子操作)